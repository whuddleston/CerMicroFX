---
title: "LTO-Ni-ML"
author: "whh36"
date: "8/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(caret)
library(randomForest)
library(e1071)
library(ipred)
library(concaveman)
```

#data splitting

```{r}
#INCLUDE PCA


#bind1 is a modified version of the original machine learning dataset
#properly filtered to match PCA dataset
#
bind1 <- voronoidens %>%
  select(-x, -count, -Labelfineshort) %>%
  select(-magx, -imagearea, -avennd) %>%
  select(-avecountarea,-avevcoarse, -countperarea) %>%
  #select(-Ni.Vol.Corrected) %>%
  select(-stressf, -aveR3) %>%
  #
  filter(Label != "WH13A") %>% #weird outlier
  filter(Label != "WH15B") %>%
  filter(Labelfine != "WH06A/1000-5-35A0006.tiff") %>%
  filter(Labelfine != "WH06C/1000-5-35C0004.tiff") %>%
  #select(-Label, -Labelfine) %>%
  #
  unique()

#bind2 allows the PCA dataset to be filtered down to Magx = 10 (machine learning doesn't have Magx=5)
bind2 <- df_particles_fine %>%
  select(Labelfine, magx) %>%
  unique()

#add PCA results to bind1
temp <- left_join(prcomp.R3.Results, bind2, by = "Labelfine") %>%
  filter(magx == 10) %>%
  select(1:7) %>%
  left_join(., bind1, by = "Labelfine") %>%
  select(-Label, -Labelfine) %>%
  mutate(condAve = log(condAve)) %>%
  filter(is.na(condAve) == FALSE)

rm(bind1)
rm(bind2)
```


```{r}
#originial machine learning dataset (see above for PCA added)
# temp <- voronoidens %>%
#   select(-x, -count, -Labelfineshort) %>%
#   select(-magx, -imagearea, -avennd) %>%
#   select(-avecountarea,-avevcoarse, -countperarea) %>%
#   #select(-Ni.Vol.Corrected) %>%
#   select(-stressf, -aveR3) %>%
#   select(-Label, -Labelfine) %>%
#   unique() %>%
#   mutate(condAve = log(condAve)) %>%
#   filter(is.na(condAve) == FALSE)

tempscaled <- as.data.frame(scale(temp))

#split into testing and training
split <- createDataPartition(temp$condAve, p = 0.7, times = 4)

trainset <- temp[as.vector(split[[1]]),]
testset <- temp[-as.vector(split[[1]]),]

#scale features
trainset <- as.data.frame(scale(trainset))
testset <- as.data.frame(scale(testset))

#summary(temp)
summary(trainset)
#summary(testset)
#rm(temp)
rm(split)

```


#models

```{r}

rfmodel <- randomForest(x = trainset, y = trainset$condAve, ntree = 300)

#remove Ni.Vol.Corrected from RF model

plot(rfmodel, main = paste("Conductivity Random Forest -", 
                        round(last(rfmodel$rsq)*100,2),
                        "% Var Explained"
                        )
     )
#print(rfmodel)
```

```{r}
rfmodimp <- importance(rfmodel) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(IncNodePurity) %>%
  filter(rowname != "condAve")

dotchart(rfmodimp$IncNodePurity, labels = rfmodimp$rowname, main = "Conductivity RF")

importance(rfmodel) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(IncNodePurity))
```

```{r}
rfresults <- predict(rfmodel, testset) %>%
  as.data.frame() %>%
  cbind(as.data.frame(testset$condAve))

colnames(rfresults)[1] <- "prediction"
colnames(rfresults)[2] <- "actual"

rflm <- lm(rfresults$prediction ~ rfresults$actual)
round(summary(rflm)$r.squared,3)


cbind(rfresults, testset) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = condAve, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  guides(color = FALSE) +
  theme_classic() +
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  coord_fixed() +
  xlab("Conductivity [S/cm]") +
  ylab("Conductivity Predicted [S/cm]")
  #annotate("text", label = round(last(rfmodel$rsq)*100,2), x = mean(rfresults$actual), y = mean(rfresults$prediction)*2)




```



```{r}
svmctrl <- trainControl(method = "LOOCV", #repeatedcv vs Leave one out cross validation
             #number = 10,
             #repeats = 10,
             #p = 0.7,
             #sampling = "up",
             )
             

consvm <- train(condAve ~ ., data = trainset, 
                method = "svmPoly", #svmLinear is worse
                trControl = svmctrl)

svmresults <- predict(consvm, testset) %>%
  as.data.frame()

colnames(svmresults)[1] <- "prediction"

svmlm <- lm(svmresults$prediction ~ testset$condAve)
round(summary(svmlm)$r.squared,3)*100

cbind(svmresults, testset) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = condAve, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  guides(color = FALSE) +
  theme_classic() +
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  #coord_fixed() +
  xlab("Conductivity [S/cm]") +
  ylab("Conductivity Predicted [S/cm]")
  #annotate("text", label = round(summary(svmlm)$r.squared,3), x = mean(testset$condAve), y = mean(svmresults$prediction)*2)

consvmimp <- varImp(consvm)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(Overall)

svmvarex <- consvm$results %>%
  select(Rsquared) %>%
  slice(which.max(Rsquared)) %>%
  as.numeric() %>%
  round(3)

dotchart(consvmimp$Overall, labels = consvmimp$rowname, 
         main = paste("Conductivity (SVM-Poly LOOCV)",
                      svmvarex*100,
                      "% Var Explained")
         )

varImp(consvm)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(Overall))


#to try: ensemble SVM / cross validate across different test/train splits
```


```{r}
#not scaled
condbag <- bagging(condAve ~., data = temp, nbagg = 25)


bagpred <- predict(condbag, temp) %>%
  as.data.frame()

colnames(bagpred)[1] <- "prediction"

cbind(bagpred, temp) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = condAve, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  coord_fixed() +
  guides(color = FALSE)
```

<!--
```{r}
#use scaled dataframe?

tbctrl <- trainControl(method = "repeatedcv",
             number = 10,
             #classProbs = TRUE,
             #sampling = "down",
             #summaryFunction = defaultSummary,
             repeats = 10)


bagCtrl <- bagControl(fit = ctreeBag$fit,
                      predict = ctreeBag$pred,
                      aggregate = ctreeBag$aggregate)


treebagresults2 <- bag(condAve~., data = trainset, bagControl = bagCtrl)

treebagpred2 <- predict(treebagresults2, testset) %>%
  as.data.frame()

colnames(treebagpred2)[1] <- "prediction"

cbind(treebagpred2, temp) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = condAve, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  coord_fixed() +
  guides(color = FALSE)

treebagimp2 <- varImp(treebagresults2)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(Overall)

dotchart(treebagimp2$Overall, labels = treebagimp2$rowname, main = "treebag")

varImp(treebagresults2)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(Overall))
```
-->


```{r}
tbctrl <- trainControl(method = "repeatedcv",
             number = 10,
             #classProbs = TRUE,
             #sampling = "down",
             #summaryFunction = defaultSummary,
             repeats = 10)

treebagresults <- train(condAve~., data = temp, method = "treebag", trControl = tbctrl)

treebagpred <- predict(treebagresults, temp) %>%
  as.data.frame()

colnames(treebagpred)[1] <- "prediction"

cbind(treebagpred, temp) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = condAve, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  coord_fixed() +
  guides(color = FALSE)

treebagimp <- varImp(treebagresults)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(Overall)

dotchart(treebagimp$Overall, labels = treebagimp$rowname, main = "treebag")

varImp(treebagresults)[1] %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(Overall))

```



<!--
```{r}
#svmBag using Caret
#nnetBag too

svmbagctrl <- trainControl(method = "cv",
             number = 10,
             selectionFunction = oneSE)
             #classProbs = TRUE,
             #sampling = "down",
             #summaryFunction = defaultSummary,
             #repeats = 10)



#str(svmBag)
#svmBag$fit

bagctrl <- bagControl(fit = svmBag$fit,
                      predict = svmBag$pred,
                      aggregate = svmBag$aggregate)


#set.seed(300)
svmsack <- train(condAve ~ ., data = tempscaled, "bag",
                 trControl = svmbagctrl, bagControl = bagctrl)

svmsack


```
-->


# Conductivity LDA

```{r}

paste("condAve","~",paste(names(trainset)[1:6], collapse = " + ")) #LDA on just pc's

paste("condAve","~",paste(names(trainset)[1:6], collapse = " + "), #LDA for con on PC's and processing
      "+ hrs",
      "+ Temp",
      "+ Ni.Vol.Corrected")




cond.lda <- paste("condAve","~", paste(names(trainset)[1:6], collapse = " + ")) %>%
  as.formula() %>%
  lda(., data = trainset)

cond.lda.prediction <- predict(cond.lda, newdata = testset)



cond.lda.prediction$x %>%
  cbind(., testset) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Ni.Vol.Corrected))) +
  #
  geom_mark_hull(aes(fill = as.factor(Ni.Vol.Corrected)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

cond.lda.prediction$x %>%
  cbind(., testset) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Temp))) +
  #
  geom_mark_hull(aes(fill = as.factor(Temp)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

cond.lda.prediction$x %>%
  cbind(., testset) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(hrs))) +
  #
  geom_mark_hull(aes(fill = as.factor(hrs)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

```

```{r}
#ni.lda
#LDA to classify for Nickel using PC's and processing

ni.lda <- paste("Ni.Vol.Corrected","~","condAve +", paste(names(trainset)[1:6], collapse = " + "), 
                "+ hrs",
                "+ Temp") %>%
  as.formula() %>%
  lda(., data = trainset)


ni.lda.prediction <- predict(ni.lda, newdata = testset)

ni.lda.prediction$x %>%
  cbind(., testset) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Ni.Vol.Corrected))) +
  #
  geom_mark_hull(aes(fill = as.factor(Ni.Vol.Corrected)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))


```



#stress modeling

```{r}
bind1 <- voronoidens %>%
  select(-x, -count, -Labelfineshort) %>%
  select(-magx, -imagearea, -avennd) %>%
  select(-avecountarea,-avevcoarse, -countperarea) %>%
  #select(-Ni.Vol.Corrected) %>%
  select(-condAve, -aveR3) %>%
  #
  filter(Label != "WH13A") %>% #weird outlier
  filter(Label != "WH15B") %>%
  filter(Labelfine != "WH06A/1000-5-35A0006.tiff") %>%
  filter(Labelfine != "WH06C/1000-5-35C0004.tiff") %>%
  #select(-Label, -Labelfine) %>%
  #
  unique()

#bind2 allows the PCA dataset to be filtered down to Magx = 10 (machine learning doesn't have Magx=5)
bind2 <- df_particles_fine %>%
  select(Labelfine, magx) %>%
  unique()

#add PCA results to bind1
temp2 <- left_join(prcomp.R3.Results, bind2, by = "Labelfine") %>%
  filter(magx == 10) %>%
  select(1:7) %>%
  left_join(., bind1, by = "Labelfine") %>%
  select(-Label, -Labelfine) %>%
  mutate(stressf2 = stressf) %>%
  select(-stressf) %>%
  filter(is.na(stressf2) == FALSE)

rm(bind1)
rm(bind2)

# temp2 <- voronoidens %>%
#   select(-x, -count, -Labelfineshort) %>%
#   select(-magx, -imagearea, -avennd) %>%
#   select(-avecountarea,-avevcoarse, -countperarea) %>%
#   #select(-Ni.Vol.Corrected) %>%
#   select(-condAve, -aveR3) %>%
#   select(-Label, -Labelfine) %>%
#   unique() %>%
#   mutate(stressf2 = stressf) %>%
#   select(-stressf) %>%
#   filter(is.na(stressf2) == FALSE)

tempscaled2 <- as.data.frame(scale(temp2))

#split into testing and training
split <- createDataPartition(temp2$stressf, p = 0.5, times = 4)

trainset2 <- temp2[as.vector(split[[1]]),]
testset2 <- temp2[-as.vector(split[[1]]),]

#scale features
trainset2 <- as.data.frame(scale(trainset2))
testset2 <- as.data.frame(scale(testset2))


rfmodels <- randomForest(x = trainset2, y = trainset2$stressf, ntree = 300)

#remove Ni.Vol.Corrected from RF model

plot(rfmodels, main = paste("Stress Random Forest -", 
                        round(last(rfmodels$rsq)*100,2),
                        "% Var Explained"
                        )
     )
#print(rfmodels)
```

```{r}
rfmodimp <- importance(rfmodels) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(IncNodePurity) %>%
  filter(rowname != "stressf2")

dotchart(rfmodimp$IncNodePurity, labels = rfmodimp$rowname, main = "Stress RF")

importance(rfmodels) %>%
  as.data.frame() %>%
  rownames_to_column() %>%
  arrange(desc(IncNodePurity))
```

```{r}
rfresultss <- predict(rfmodels, testset2) %>%
  as.data.frame() %>%
  cbind(as.data.frame(testset2$stressf))

colnames(rfresultss)[1] <- "prediction"
colnames(rfresultss)[2] <- "actual"

#rflms <- lm(rfresultss$prediction ~ rfresultss$actual)
#round(summary(rflms)$r.squared,3)


cbind(rfresultss, testset2) %>%
  ggplot() +
  geom_point(aes(y = prediction, x = stressf2, color = as.factor(Ni.Vol.Corrected))) +
  geom_abline(slope = 1, intercept = 0) +
  guides(color = FALSE) +
  theme_classic() +
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  coord_fixed() +
  xlab(expression(sigma[fr]~'['*MPa*']')) +
  ylab(expression(sigma[fr]~'-'~predicted~'['*MPa*']')) 
  #annotate("text", label = round(last(rfmodels$rsq)*100,2), x = mean(rfresultss$actual), y = mean(rfresultss$prediction)*2)
```

#stress LDA

```{r}
#LDA on just pc's

paste(last(names(trainset2)),"~", paste(names(trainset2)[1:6], collapse = " + "))

stress.lda <- paste(last(names(trainset2)),"~", paste(names(trainset2)[1:6], collapse = " + ")) %>%
  as.formula() %>%
  lda(., data = trainset2)

stress.lda.prediction <- predict(stress.lda, newdata = testset2)


stress.lda.prediction$x %>%
  cbind(., testset2) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Ni.Vol.Corrected))) +
  #
  geom_mark_hull(aes(fill = as.factor(Ni.Vol.Corrected)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

stress.lda.prediction$x %>%
  cbind(., testset2) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Temp))) +
  #
  geom_mark_hull(aes(fill = as.factor(Temp)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

stress.lda.prediction$x %>%
  cbind(., testset2) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(hrs))) +
  #
  geom_mark_hull(aes(fill = as.factor(hrs)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

stress.lda.prediction$x %>%
  cbind(., testset2) %>%
  ggplot(aes(LD1, LD3)) +
  geom_point(aes(color = as.factor(hrs))) +
  #
  geom_mark_hull(aes(fill = as.factor(hrs)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))

#stress.lda.prediction$posterior %>% as.data.frame()

#plot(stress.lda)

```

```{r}
#temp LDA

temp.lda <- paste("Temp","~","stressf2 +", paste(names(trainset2)[1:6], collapse = " + "), 
                "+ hrs",
                "+ Ni.Vol.Corrected") %>%
  as.formula() %>%
  lda(., data = trainset2)

temp.lda.prediction <- predict(temp.lda, newdata = testset2)

temp.lda.prediction$x %>%
  cbind(., testset2) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Temp))) +
  #
  geom_mark_hull(aes(fill = as.factor(Temp)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))
```

```{r}
#want to do LDA on few variables using all data
#also want to do LDA on all variables for split data

temp.lda <- paste("Temp","~","stressf2 +", paste(names(tempscaled2)[1:6], collapse = " + "), 
                "+ hrs",
                "+ Ni.Vol.Corrected") %>%
  as.formula() %>%
  lda(., data = tempscaled2)

temp.lda.prediction <- predict(temp.lda, newdata = tempscaled2)

temp.lda.prediction$x %>%
  cbind(., tempscaled2) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Temp))) +
  #
  geom_mark_hull(aes(fill = as.factor(Temp)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))



ni.lda <- paste("Ni.Vol.Corrected","~","condAve +", paste(names(tempscaled)[1:6], collapse = " + "), 
                "+ hrs",
                "+ Temp") %>%
  as.formula() %>%
  lda(., data = tempscaled)


ni.lda.prediction <- predict(ni.lda, newdata = tempscaled)

ni.lda.prediction$x %>%
  cbind(., tempscaled) %>%
  ggplot(aes(LD1, LD2)) +
  geom_point(aes(color = as.factor(Ni.Vol.Corrected))) +
  #
  geom_mark_hull(aes(fill = as.factor(Ni.Vol.Corrected)), expand = 0.02) +
  #
  scale_x_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  scale_y_continuous(sec.axis = sec_axis(~., labels = NULL)) +
  theme_classic() +
  theme(axis.text.x = element_text(colour = "black", size = 16),
        axis.text.y = element_text(colour = "black", size = 16),
        axis.ticks = element_line(colour = "black", size = 1),
        axis.line = element_line(colour = 'black', size = 1),
        axis.title.x = element_text(colour = "black", size = 16),
        axis.title.y = element_text(colour = "black", size = 16),
        legend.text = element_text(colour="black", size = 12))





paste("y","~", paste(names(trainset2)[-length(names(trainset2))], collapse = " + ")) #%>%
#   as.formula() %>%
#   lda(., data = trainset2)

```



